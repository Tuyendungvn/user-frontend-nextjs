{"ast":null,"code":"const createImage = url => new Promise((resolve, reject) => {\n  const image = new Image();\n  image.addEventListener(\"load\", () => resolve(image));\n  image.addEventListener(\"error\", error => reject(error));\n  image.setAttribute(\"crossOrigin\", \"anonymous\"); // needed to avoid cross-origin issues on CodeSandbox\n\n  image.src = url;\n});\n/**\n * @param {File} image - Image File url\n * @param {Object} pixelCrop - pixelCrop Object provided by react-easy-crop\n *\n * @returns {Object} { file, base64File }\n *\n */\n\n\nexport const getCroppedImg = async (imageSrc, pixelCrop, fileType = \"image/jpeg\") => {\n  const image = await createImage(imageSrc);\n  const canvas = document.createElement(\"canvas\");\n  const ctx = canvas.getContext(\"2d\");\n  const maxSize = Math.max(image.width, image.height);\n  const safeArea = 2 * (maxSize / 2 * Math.sqrt(2)); // set each dimensions to double largest dimension to allow for a safe area for the\n  // image to rotate in without being clipped by canvas context\n\n  canvas.width = safeArea;\n  canvas.height = safeArea; // translate canvas context to a central location on image to allow rotating around the center.\n\n  ctx === null || ctx === void 0 ? void 0 : ctx.translate(safeArea / 2, safeArea / 2);\n  ctx === null || ctx === void 0 ? void 0 : ctx.translate(-safeArea / 2, -safeArea / 2); // draw rotated image and store data.\n\n  ctx === null || ctx === void 0 ? void 0 : ctx.drawImage(image, safeArea / 2 - image.width * 0.5, safeArea / 2 - image.height * 0.5);\n  const data = ctx === null || ctx === void 0 ? void 0 : ctx.getImageData(0, 0, safeArea, safeArea); // set canvas width to final desired crop size - this will clear existing context\n\n  canvas.width = pixelCrop.width;\n  canvas.height = pixelCrop.height; // paste generated rotate image with correct offsets for x,y crop values.\n\n  ctx === null || ctx === void 0 ? void 0 : ctx.putImageData(data, Math.round(0 - safeArea / 2 + image.width * 0.5 - pixelCrop.x), Math.round(0 - safeArea / 2 + image.height * 0.5 - pixelCrop.y)); // As Base64 string\n  // As a blob\n\n  return new Promise(resolve => {\n    canvas.toBlob(blob => {\n      try {\n        const base64File = canvas.toDataURL(fileType);\n        const file = new File([blob], `fileName.${fileType === \"image/jpeg\" ? \"jpg\" : \"png\"}`, {\n          type: fileType\n        });\n        resolve({\n          file,\n          base64File\n        });\n      } catch (error) {\n        console.error(error);\n      }\n    }, fileType);\n  });\n};","map":null,"metadata":{},"sourceType":"module"}